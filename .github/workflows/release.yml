name: Create Release

on:
  workflow_dispatch:
    inputs:
      release_notes:
        description: 'Release notes'
        required: false
        default: 'New release of Brownie''s Addon Manager'
  push:
    branches: [ main ]
    paths: [ 'package.json' ]

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      version-changed: ${{ steps.check.outputs.changed }}
      new-version: ${{ steps.check.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
        
    - name: Check if version changed
      id: check
      run: |
        # Get current version
        CURRENT_VERSION=$(jq -r '.version' package.json)
        
        # Get previous version (from previous commit)
        git checkout HEAD~1 -- package.json 2>/dev/null || echo "No previous version"
        PREVIOUS_VERSION=$(jq -r '.version' package.json 2>/dev/null || echo "0.0.0")
        
        # Restore current package.json
        git checkout HEAD -- package.json
        
        echo "Previous version: $PREVIOUS_VERSION"
        echo "Current version: $CURRENT_VERSION"
        
        if [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
          echo "Version changed from $PREVIOUS_VERSION to $CURRENT_VERSION"
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "version=v$CURRENT_VERSION" >> $GITHUB_OUTPUT
        else
          echo "Version unchanged"
          echo "changed=false" >> $GITHUB_OUTPUT
        fi

  build-and-release:
    needs: check-version
    if: needs.check-version.outputs.version-changed == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: windows-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        
    - name: Get version from package.json
      id: package-version
      run: |
        $version = (Get-Content package.json | ConvertFrom-Json).version
        echo "version=v$version" >> $env:GITHUB_OUTPUT
        echo "raw_version=$version" >> $env:GITHUB_OUTPUT
        
    - name: Generate release notes from commits
      id: release-notes
      run: |
        # Get the latest release tag
        $latestTag = git describe --tags --abbrev=0 2>$null
        if ($LASTEXITCODE -ne 0) {
          $latestTag = ""
        }
        
        # Generate commit messages since last release
        if ($latestTag) {
          $commits = git log "$latestTag..HEAD" --pretty=format:"- %s" --no-merges
        } else {
          $commits = git log --pretty=format:"- %s" --no-merges -n 10
        }
        
        if ($commits) {
          $releaseNotes = @"
        ### Changes in this release:
        
        $commits
        "@
        } else {
          $releaseNotes = "- Initial release"
        }
        
        # Escape for GitHub output
        $releaseNotes = $releaseNotes -replace "`r`n", "%0A" -replace "`n", "%0A"
        echo "notes=$releaseNotes" >> $env:GITHUB_OUTPUT
        
    - name: Install dependencies
      run: npm install
      
    - name: Build React app
      run: npm run build
      
    - name: Build Electron app and publish
      run: npm run publish
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Code sign Windows installers
      if: runner.os == 'Windows'
      shell: powershell
      env:
        PFX_BASE64: ${{ secrets.cert_pfx }}
        PFX_PASSWORD: ${{ secrets.CERTSECRECT }}
      run: |
        # Decode the Base64 PFX into a temp file
        $pfxPath = Join-Path $env:TEMP "github_signing_cert.pfx"
        Write-Host "Writing PFX to $pfxPath"
        [System.IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:PFX_BASE64))

        # Locate signtool.exe - it's installed with Windows SDK. Try common locations and PATH.
        $signtool = Get-Command signtool -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source -ErrorAction SilentlyContinue
        if (-not $signtool) {
          $possible = @("$env:ProgramFiles(x86)\Windows Kits\10\bin\x64\signtool.exe", "$env:ProgramFiles(x86)\Windows Kits\10\bin\x86\signtool.exe")
          foreach ($p in $possible) { if (Test-Path $p) { $signtool = $p; break } }
        }

        if (-not $signtool) {
          Write-Error "signtool.exe not found on runner. Ensure Windows SDK is available or install it before this step."
          exit 1
        }

        Write-Host "Using signtool: $signtool"

        # Find artifacts to sign - default to dist\*.exe
        $artifacts = Get-ChildItem -Path "dist" -Filter "*.exe" -File -ErrorAction SilentlyContinue
        if (-not $artifacts) {
          Write-Host "No .exe files found in dist/ to sign. Skipping signing."
        } else {
          foreach ($f in $artifacts) {
            Write-Host "Signing $($f.FullName)"
            & $signtool sign /f $pfxPath /p $env:PFX_PASSWORD /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 /v $f.FullName
            if ($LASTEXITCODE -ne 0) { Write-Error "Signing failed for $($f.FullName)"; exit $LASTEXITCODE }
          }
        }

        # Cleanup sensitive file
        Remove-Item -Path $pfxPath -Force -ErrorAction SilentlyContinue
        
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.package-version.outputs.version }}
        name: Brownie's Addon Manager ${{ steps.package-version.outputs.version }}
        body: |
          ## Brownie's Addon Manager ${{ steps.package-version.outputs.version }}
          
          ${{ github.event.inputs.release_notes || steps.release-notes.outputs.notes }}
          
          ### Installation
          1. Download the installer below
          2. Run the .exe file to install
          3. Launch Brownie's Addon Manager
          4. Configure your WoW installation path in Settings
          5. Start managing your addons!
        draft: false
        prerelease: false
        files: dist/*.exe
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
