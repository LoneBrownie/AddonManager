name: Create Release

on:
  workflow_dispatch:
    inputs:
      release_notes:
        description: 'Release notes'
        required: false
        default: 'New release of Brownie''s Addon Manager'
  push:
    branches: [ main ]
    paths: [ 'package.json' ]

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      version-changed: ${{ steps.check.outputs.changed }}
      new-version: ${{ steps.check.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
        
    - name: Check if version changed
      id: check
      run: |
        # Get current version
        CURRENT_VERSION=$(jq -r '.version' package.json)
        
        # Get previous version (from previous commit)
        git checkout HEAD~1 -- package.json 2>/dev/null || echo "No previous version"
        PREVIOUS_VERSION=$(jq -r '.version' package.json 2>/dev/null || echo "0.0.0")
        
        # Restore current package.json
        git checkout HEAD -- package.json
        
        echo "Previous version: $PREVIOUS_VERSION"
        echo "Current version: $CURRENT_VERSION"
        
        if [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
          echo "Version changed from $PREVIOUS_VERSION to $CURRENT_VERSION"
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "version=v$CURRENT_VERSION" >> $GITHUB_OUTPUT
        else
          echo "Version unchanged"
          echo "changed=false" >> $GITHUB_OUTPUT
        fi

  build-and-release:
    needs: check-version
    if: needs.check-version.outputs.version-changed == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: windows-latest
    permissions:
      contents: write
      id-token: write  # Required for OIDC token access
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        
    - name: Get version from package.json
      id: package-version
      run: |
        $version = (Get-Content package.json | ConvertFrom-Json).version
        echo "version=v$version" >> $env:GITHUB_OUTPUT
        echo "raw_version=$version" >> $env:GITHUB_OUTPUT
        
    - name: Generate release notes from commits
      id: release-notes
      run: |
        # Get the latest release tag
        $latestTag = git describe --tags --abbrev=0 2>$null
        if ($LASTEXITCODE -ne 0) {
          $latestTag = ""
        }
        
        # Generate commit messages since last release
        if ($latestTag) {
          $commits = git log "$latestTag..HEAD" --pretty=format:"- %s" --no-merges
        } else {
          $commits = git log --pretty=format:"- %s" --no-merges -n 10
        }
        
        if ($commits) {
          $releaseNotes = "### Changes in this release:`n`n$commits"
        } else {
          $releaseNotes = "- Initial release"
        }
        
        # Use proper multiline output for GitHub Actions
        $delimiter = "EOF$(Get-Random)"
        echo "notes<<$delimiter" >> $env:GITHUB_OUTPUT
        echo $releaseNotes >> $env:GITHUB_OUTPUT
        echo $delimiter >> $env:GITHUB_OUTPUT
        
    - name: Install dependencies
      run: npm install
      
    - name: Build React app
      run: npm run build
      
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3.6.0
      with:
        cosign-release: 'v2.2.4'
        
    - name: Build Electron app (no publish)
      run: npm run dist
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Generate update metadata
      run: |
        # Generate latest.yml for electron-updater
        # This file is required for the auto-updater to work properly
        # It contains version info, file hashes, and download URLs
        $version = "${{ steps.package-version.outputs.raw_version }}"
        $setupFile = Get-ChildItem -Path "dist" -Filter "*Setup*.exe" | Select-Object -First 1
        $blockmapFile = Get-ChildItem -Path "dist" -Filter "*Setup*.exe.blockmap" | Select-Object -First 1
        
        if ($setupFile -and $blockmapFile) {
          $setupSize = $setupFile.Length
          $setupSha512 = (Get-FileHash -Path $setupFile.FullName -Algorithm SHA512).Hash.ToLower()
          $blockmapSize = $blockmapFile.Length
          $blockmapSha512 = (Get-FileHash -Path $blockmapFile.FullName -Algorithm SHA512).Hash.ToLower()
          $releaseDate = Get-Date -Format "yyyy-MM-ddTHH:mm:ss.fffZ"
          
          Write-Host "Setup file: $($setupFile.Name)"
          Write-Host "File size: $setupSize bytes"
          
          # GitHub converts certain characters in filenames when uploading
          # Convert apostrophes and spaces to dots to match GitHub's behavior
          $githubFileName = $setupFile.Name -replace "'", "." -replace " ", "."
          Write-Host "GitHub filename will be: $githubFileName"
          
          $latestYml = "version: $version`n" +
                       "files:`n" +
                       "  - url: $githubFileName`n" +
                       "    sha512: $setupSha512`n" +
                       "    size: $setupSize`n" +
                       "    blockMapSize: $blockmapSize`n" +
                       "path: $githubFileName`n" +
                       "sha512: $setupSha512`n" +
                       "releaseDate: $releaseDate"
          
          $latestYml | Out-File -FilePath "dist/latest.yml" -Encoding UTF8
          Write-Host "Generated latest.yml for electron-updater"
          Get-Content "dist/latest.yml"
          
          # Validate the generated YAML
          try {
            $yamlContent = Get-Content "dist/latest.yml" -Raw
            Write-Host "✓ latest.yml generated successfully"
          } catch {
            Write-Error "✗ Failed to read generated latest.yml: $_"
            exit 1
          }
        } else {
          Write-Error "Setup file or blockmap file not found"
          exit 1
        }

    - name: Verify release files
      run: |
        Write-Host "Verifying all required files for electron-updater..."
        Write-Host "Files in dist directory:"
        Get-ChildItem -Path "dist" -Filter "*.exe" | ForEach-Object { Write-Host "  $($_.Name)" }
        Get-ChildItem -Path "dist" -Filter "*.blockmap" | ForEach-Object { Write-Host "  $($_.Name)" }
        Get-ChildItem -Path "dist" -Filter "*.yml" | ForEach-Object { Write-Host "  $($_.Name)" }
        
        $requiredFiles = @(
          "dist/*Setup*.exe",
          "dist/*Setup*.exe.blockmap", 
          "dist/latest.yml"
        )
        
        foreach ($pattern in $requiredFiles) {
          $files = Get-ChildItem -Path $pattern -ErrorAction SilentlyContinue
          if ($files) {
            Write-Host "✓ Found: $($files.Name -join ', ')"
          } else {
            Write-Error "✗ Missing: $pattern"
            exit 1
          }
        }
        
        Write-Host "`nAll required files for electron-updater are present!"
        Write-Host "`nContents of latest.yml:"
        Get-Content "dist/latest.yml"

    - name: Sign executables with Cosign
      shell: powershell
      run: |
        # Find all Setup .exe files in dist directory
        $artifacts = Get-ChildItem -Path "dist" -Filter "*Setup*.exe" -File -ErrorAction SilentlyContinue
        if (-not $artifacts) {
          Write-Host "No Setup .exe files found in dist/ to sign. Skipping signing."
          exit 0
        }
        
        foreach ($artifact in $artifacts) {
          Write-Host "Signing $($artifact.FullName) with Cosign..."
          
          # Sign with keyless signing using GitHub OIDC token
          cosign sign-blob --yes $artifact.FullName --output-signature "$($artifact.FullName).sig" --output-certificate "$($artifact.FullName).crt"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Cosign signing failed for $($artifact.FullName)"
            exit $LASTEXITCODE
          }
          
          Write-Host "Successfully signed $($artifact.FullName)"
          Write-Host "Signature: $($artifact.FullName).sig"
          Write-Host "Certificate: $($artifact.FullName).crt"
        }
        
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.package-version.outputs.version }}
        name: Brownie's Addon Manager ${{ steps.package-version.outputs.version }}
        body: |
          ## Brownie's Addon Manager ${{ steps.package-version.outputs.version }}
          
          ${{ github.event.inputs.release_notes || steps.release-notes.outputs.notes }}
          
          ### Installation
          1. Download the installer below
          2. Run the .exe file to install
          3. Launch Brownie's Addon Manager
          4. Configure your WoW installation path in Settings
          5. Start managing your addons!
        draft: false
        prerelease: false
        files: |
          dist/*Setup*.exe
          dist/*Setup*.exe.blockmap
          dist/latest.yml
          dist/*Setup*.exe.sig
          dist/*Setup*.exe.crt
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Cleanup temporary files
      if: always()
      shell: powershell
      run: |
        # Clean up any temporary signing artifacts if needed
        Write-Host "Build and signing process completed"
